#include <stdio.h>
#include <stdlib.h>
#include <math.h> //Απαραίτητη βιβλιοθήκη για την χρήση των fabs(), fabsl() και pow().

long double f(long double, double[6]); //Δήλωση συνάρτησης που υπολογίζει το f(x0).
long double df(long double, double[6]); //Δήλωση συνάρτησης που υπολογίζει το f'(x0).

int main(int argc, char *argv[])
{
    char *stopstring; //Δήλωση μεταβλητής τύπου char* για τις ανάγκες της strtod().
    double FACT[6]; //Δήλωση array που αποθηκεύει τα ορίσματα που αφορούν τους συντελεστές του πολυωνύμου.
    long double x0 = strtod(argv[7], &stopstring); //Αρχικοποίηση της μεταβλητής x0 με το όρισμα που αφορά την αρχική τιμή x0 με την οποία εκτελείται το πρόγραμμα.
    long double x = 0; //Αρχικοποίηση της μεταβλητής που θα κρατάει το αποτέλεσμα του υπολογισμού σε κάθε επανάληψη.
    long double fx0, dfx0; //Δήλωση μεταβλητών που θα κρατάνε την τιμή του f(x0) και του f'(x0) σε κάθε επανάληψη.

    if(argc != 8) { //Έλεγχος αν δώθηκε το σωστό πλήθος ορισμάτων.
        return 1;
    }

    for (int i = 0; i < 6; i++) { //Επανάληψη για να περάσουμε τους συντελεστές του πολυωνύμου από τον πίνακα ορισμάτων στον πίνακα συντελεστών που θα χρησιμοποιήσουμε.
        FACT[i] = strtod(argv[i+1], &stopstring);
    }

    for(int i = 0; i < 1000; i++){ //Επανάληψη υπολογισμού ρίζας που εκτελείται το πολύ για 1000 επαναλήψεις.

        fx0 = f(x0, FACT); //Υπολογισμός f(x0).
        dfx0 = df(x0, FACT); //Υπολογισμός f'(x0).
        
        x = x0 - fx0/dfx0; //Υπολογισμός του τύπου προσέγγισης της ρίζας.

        if(isnan(x)) { //Έλεγχος αν το αποτέλεσμα του υπολογισμού ήταν nan.
            printf("nan\n");
            return 0;
        }

        if (fabsl(x - x0) < pow(10, -6)) { //Έλεγχος αν η τρέχουσα προσέγγιση είναι αρκετά ακριβής. Αν είναι τότε εκτυπώνεται και το πρόγραμμα τερματίζει.
            printf("%.2Lf\n", x);
            return 0;
        }

        x0 = x; //Αποθήκευση της τρέχουσας προσέγγισης της ρίζας στην μεταβλητή x0 για χρήση στην επόμενη επανάληψη. 
    }
        
    printf("incomplete\n"); //Αυτή η εντολή εκτελείται μόνο αν η επανάληψη έχει εκτελεστεί 1000 φορές και δεν έχει προκύψει αποδεκτή προσέγγιση ή δεν πάει να γίνει διαίρεση με το 0.
    return 0;
}

long double f(long double x0, double FACT[6])
{
    return (FACT[0] + FACT[1] * x0 + FACT[2] * pow(x0, 2) + FACT[3] * pow(x0, 3) + FACT[4] * pow(x0, 4) + FACT[5] * pow(x0, 5)); //Υπολογισμός f(x0).
}

long double df(long double x0, double FACT[6])
{
    return (FACT[1] + 2 * FACT[2] * x0 + 3 * FACT[3] * pow(x0, 2) + 4 * FACT[4] * pow(x0, 3) + 5 * FACT[5] * pow(x0, 4)); //Υπολογισμός f'(x0).
}
